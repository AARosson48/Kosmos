<html>
	<head>
		<title>Kosmos</title>
		<link href="style.css" rel="stylesheet" type="text/css"/>

		<script>
			function jsMain() {
				// correct canvas dimensions due to sidebar
				document.getElementById("rightbar").style.width = 
					(document.getElementById("kosmosCanvas").clientWidth - document.getElementById("sidebar").clientWidth) + "px";

				// CoffeeScript code entry point
				kosmosMain();
			}

			function hideIntro() {
				var msg = document.getElementById("introMessage");
				msg.style.display = "none";
				//msg.parentNode.removeChild(msg);
			}
			function showIntro() {
				var msg = document.getElementById("introMessage");
				msg.style.display = "block";
			}
		</script>
	</head>
	<body onload="jsMain();">
		<div class="sidebar" id="sidebar">
			<table border="0" cellpadding="0" cellspacing="0" height="100%" width="100%"><tr><td>

			<span class="title" style="cursor: pointer;" onClick="showIntro();">Kosmos</span>
			<span class="subtitle">Virtual 3D Universe</span>

			</td></tr><tr valign="middle" height="100%"><td valign="middle" height="100%">

			<div class="btn">Forward x100</div>
			<div class="btn">Forward x10</div>
			<div class="btn">Forward x1</div>
			<div class="btn redlit">Stop</div>
			<div class="btn">Reverse x1</div>
			<div class="btn">Reverse x10</div>
			<div class="btn">Reverse x100</div>

			</td></tr><tr><td height="30px">
			
			<a href="http://judnich.github.com"><span class="footer">Copyright Â© 2013 John Judnich</span></a>

			</td></tr></table>
		</div>

		<div class="rightbar" id="rightbar">
			<canvas id="kosmosCanvas" onClick="hideIntro();"/>
		</div>

		<div class="message" id="introMessage">
			<div class="title">Welcome to Kosmos</div>
			<p><i>Kosmos allows you to explore a computer-generated 3D universe from your browser.</i></p>
			<p>Click anywhere to navigate, adjusting speed using the buttons on the left.</p>
			<div class="okButton" onClick="hideIntro();">Ok</div>
		</div>

		<script id="shader-fs" type="x-shader/x-fragment">
		    precision mediump float;

		    varying vec4 vColor;

		    void main(void) {
		        gl_FragColor = vec4(1, 1, 1, 1); //vColor;
		    }
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">
		    attribute vec3 inPos;

		    uniform mat4 modelViewMat;
		    uniform mat4 projMat;

		    varying vec4 vColor;

		    void main(void) {
		        gl_Position = projMat * modelViewMat * vec4(inPos, 1.0);
		        vColor = vec4(1, 1, 1, 1);
		    }
		</script>

		<script id="starfield-fs" type="x-shader/x-fragment">
		    precision mediump float;

		    varying vec3 vUVA;
		    varying vec3 vColor;

		    void main(void) {
		    	// compute star color based on intensity = 1/dist^2 from center of sprite
		    	vec2 dv = vUVA.xy - vec2(0.5, 0.5);
		    	float d = dot(dv, dv);
		    	float lum = 1.0 / (d*100.0);
		    	//float c = 1.0 / (d*10.0);
		    	//c = clamp(0.5 - d, 0.0, 1.0) * c;

		    	vec4 pColor = vec4(clamp(lum*vColor.x, 0.0, 1.0), clamp(lum*vColor.y, 0.0, 1.0), clamp(lum*vColor.z, 0.0, 1.0), 1.0);
		        gl_FragColor = pColor * vUVA.z;
		    }
		</script>

		<script id="starfield-vs" type="x-shader/x-vertex">
		    attribute vec4 aPos;
		    attribute vec2 aUV;

		    uniform mat4 projMat;
		    uniform mat4 modelViewMat;
		    uniform vec2 starSizeAndViewRange;
		    //uniform mat4 modelMat;
		    //uniform mat4 viewMat;

		    varying vec3 vUVA;
		    varying vec3 vColor;

		    void main(void) {
		    	// determine star size
		    	float starSize = starSizeAndViewRange.x;
		    	//starSize = starSize * (cos(aPos.w*1000.0) * 0.5 + 1.0); // modulate size by simple PRNG

		    	// compute vertex position so quad is always camera-facing
		    	vec4 pos = vec4(aPos.xyz, 1.0);
		    	vec2 offset = (aUV - 0.5) * starSize;

		    	//pos = viewMat * modelMat * pos;
		    	pos = modelViewMat * pos;
		    	pos.xy += offset;

		    	// fade out distant stars
		    	float dist = length(pos.xyz);
		    	float alpha = clamp((1.0 - (dist / starSizeAndViewRange.y)) * 4.0, 0.0, 1.0);

		        // the UV coordinates are used to render the actual star radial gradient,
		        // and alpha is used to modulate intensity of distant stars as they fade out
		        vUVA = vec3(aUV, alpha);

		        // compute star color parameter
		        // this is just an arbitrary hand-tweaked interpolation between blue/white/red
		        // favoring mostly blue and white with some red
		        vColor = vec3(1.0 - aPos.w, aPos.w*2.0*(1.0-aPos.w), 2.0 * aPos.w) * 0.5 + 0.5;

		    	// output position, or degenerate triangle if star is beyond view range
		    	if (alpha > 0.0)
		        	gl_Position = projMat * pos;
		        else
		        	gl_Position = vec4(0, 0, 0, 0);
		    }
		</script>

		<script type="text/javascript" src="external/gl-matrix-min.js"></script>
		<script type="text/javascript" src="external/webgl-utils.js"></script>
		<script type="text/javascript" src="compiled/xgl.js"></script>
		<script type="text/javascript" src="compiled/RandomStream.js"></script>
		<script type="text/javascript" src="compiled/Bounds.js"></script>
		<script type="text/javascript" src="compiled/Camera.js"></script>
		<script type="text/javascript" src="compiled/StarField.js"></script>
		<script type="text/javascript" src="compiled/Main.js"></script>

	</body>
</html>
